{"version":3,"file":"index.js","sources":["../src/snippets.ts","../src/completion.ts","../src/feel.ts"],"sourcesContent":["import { Completion, snippetCompletion } from '@codemirror/autocomplete';\n\n/**\n * A collection of FEEL-related [snippets](#autocomplete.snippet).\n */\nexport const snippets: readonly Completion[] = [\n  snippetCompletion('function(${params}) ${body}', {\n    label: 'function',\n    detail: 'definition',\n    type: 'keyword'\n  }),\n  snippetCompletion('for ${var} in ${collection} return ${value}', {\n    label: 'for',\n    detail: 'expression',\n    type: 'keyword'\n  }),\n  snippetCompletion('every ${var} in ${collection} satisfies ${condition}', {\n    label: 'every',\n    detail: 'quantified expression',\n    type: 'keyword'\n  }),\n  snippetCompletion('some ${var} in ${collection} satisfies ${condition}', {\n    label: 'some',\n    detail: 'quantified expression',\n    type: 'keyword'\n  }),\n  snippetCompletion('if ${condition} then ${value} else ${other value}', {\n    label: 'if',\n    detail: 'block',\n    type: 'keyword'\n  }),\n  snippetCompletion('{ ${key}: ${value} }', {\n    label: 'context',\n    detail: 'block',\n    type: 'keyword'\n  }),\n  snippetCompletion('null', {\n    label: 'null',\n    detail: 'literal',\n    type: 'keyword'\n  }),\n  snippetCompletion('true', {\n    label: 'true',\n    detail: 'literal',\n    type: 'keyword'\n  }),\n  snippetCompletion('false', {\n    label: 'false',\n    detail: 'literal',\n    type: 'keyword'\n  })\n];\n","import { syntaxTree } from '@codemirror/language';\nimport { SyntaxNode } from '@lezer/common';\n\nimport {\n  CompletionSource,\n  Completion,\n  completeFromList,\n  CompletionContext\n} from '@codemirror/autocomplete';\n\n\nexport function contextualKeyword(options: {\n  before?: string,\n  after?: string,\n  context: string,\n  keyword: string\n}) : CompletionSource {\n\n  const {\n    context: nodes,\n    after,\n    before,\n    keyword\n  } = options;\n\n  return ifInside({ nodes, before, after, keyword }, completeFromList([\n    { label: keyword, type: 'keyword', boost: 10 }\n  ]));\n}\n\nexport const keywordCompletions = [\n  contextualKeyword({\n    context: 'InExpression',\n    keyword: 'in'\n  }),\n  contextualKeyword({\n    context: 'IfExpression',\n    keyword: 'then',\n    after: 'if',\n    before: 'else'\n  }),\n  contextualKeyword({\n    context: 'IfExpression',\n    keyword: 'else',\n    after: 'then'\n  }),\n  contextualKeyword({\n    context: 'QuantifiedExpression',\n    keyword: 'satisfies'\n  }),\n  contextualKeyword({\n    context: 'ForExpression',\n    after: 'InExpressions',\n    keyword: 'return'\n  })\n];\n\nexport const dontComplete = [\n  'StringLiteral', 'Identifier',\n  'LineComment', 'BlockComment',\n  'PathExpression', 'Context',\n  'Key', 'ParameterName'\n];\n\nexport const doComplete = [\n  'Expr',\n  'ContextEntry'\n];\n\nexport function ifExpression(completionSource: CompletionSource) : CompletionSource {\n\n  const allNodes = [ ...dontComplete, ...doComplete ];\n\n  return (context: CompletionContext) => {\n\n    const { state, pos } = context;\n\n    const match = matchUp(syntaxTree(state).resolveInner(pos, -1), allNodes);\n\n    if (match) {\n\n      const [ _, name ] = match;\n\n      if (dontComplete.includes(name)) {\n        return null;\n      }\n    }\n\n    return completionSource(context);\n  };\n}\n\nexport function snippetCompletion(snippets: readonly Completion[]) : CompletionSource {\n  return ifExpression(\n    completeFromList(snippets.map(s => ({ ...s, type: 'text' })))\n  );\n}\n\nexport function matchLeft(node: SyntaxNode, position: number, nodes: (string|undefined)[]) : SyntaxNode | null {\n  return matchChildren(node, position, nodes, -1);\n}\n\nexport function matchRight(node: SyntaxNode, position: number, nodes: (string|undefined)[]) : SyntaxNode | null {\n  return matchChildren(node, position, nodes, 1);\n}\n\nexport function matchChildren(node: SyntaxNode, position: number, nodes: (string|undefined)[], direction: 1 | -1) : SyntaxNode | null {\n\n  let child = node[direction > 0 ? 'childAfter' : 'childBefore'](position);\n\n  while (child) {\n    if (nodes.includes(child.name)) {\n      return child;\n    }\n\n    if (child.type.isError && child.firstChild) {\n      if (nodes.includes(child.firstChild.name)) {\n        return child.firstChild;\n      }\n    }\n\n    child = child[direction > 0 ? 'nextSibling' : 'prevSibling'];\n  }\n\n  return null;\n}\n\nfunction matchUp(node: SyntaxNode, nodeNames: string | string[]) : [ SyntaxNode, string ] | null {\n\n  if (!Array.isArray(nodeNames)) {\n    nodeNames = [ nodeNames ];\n  }\n\n  for (; node; node = node.parent!) {\n\n    const nodeType = node.type;\n\n    const matchedName = nodeNames.find(name => name && nodeType.is(name));\n\n    if (matchedName) {\n      return [ node, matchedName ];\n    }\n\n    if (nodeType.isTop) {\n      break;\n    }\n  }\n\n  return null;\n}\n\nexport function ifInside(options: {\n  nodes: string | string[],\n  keyword: string,\n  before?: string,\n  after?: string\n}, source: CompletionSource): CompletionSource {\n\n  const {\n    nodes,\n    before,\n    after,\n    keyword\n  } = options;\n\n  return (context) => {\n\n    const { state, pos } = context;\n\n    const match = matchUp(syntaxTree(state).resolveInner(pos, -1), nodes);\n\n    if (!match) {\n      return null;\n    }\n\n    const [ node ] = match;\n\n    if (matchLeft(node, pos, [ keyword, before ])) {\n      return null;\n    }\n\n    if (matchRight(node, pos, [ keyword, after ])) {\n      return null;\n    }\n\n    if (after && !matchLeft(node, pos, [ after ])) {\n      return null;\n    }\n\n    return source(context);\n  };\n}","import {\n  parser,\n  trackVariables\n} from 'lezer-feel';\n\nimport {\n  LRLanguage,\n  LanguageSupport,\n  delimitedIndent,\n  continuedIndent,\n  indentNodeProp,\n  foldNodeProp,\n  foldInside\n} from '@codemirror/language';\n\nimport {\n  snippets\n} from './snippets';\n\nimport {\n  keywordCompletions,\n  snippetCompletion\n} from './completion';\n\nimport {\n  CompletionSource\n} from '@codemirror/autocomplete';\n\n\n/**\n * A FEEL language provider based on the\n * [Lezer FEEL parser](https://github.com/nikku/lezer-feel),\n * extended with highlighting and indentation information.\n */\nexport const feelLanguage = LRLanguage.define({\n  parser: parser.configure({\n    props: [\n      indentNodeProp.add({\n        'Context': delimitedIndent({\n          closing: '}'\n        }),\n        'List FilterExpression': delimitedIndent({\n          closing: ']'\n        }),\n        'ParenthesizedExpression FunctionInvocation': continuedIndent({\n          except: /^\\s*\\)/\n        }),\n        'ForExpression QuantifiedExpression IfExpression': continuedIndent({\n          except: /^\\s*(then|else|return|satisfies)\\b/\n        }),\n        'FunctionDefinition': continuedIndent({\n          except: /^\\s*(\\(|\\))/\n        })\n      }),\n      foldNodeProp.add({\n        Context: foldInside,\n        List: foldInside,\n        ParenthesizedExpression: foldInside,\n        FunctionDefinition(node) {\n          const last = node.getChild(')');\n\n          if (!last) return null;\n\n          return {\n            from: last.to,\n            to: node.to\n          };\n        }\n      })\n    ]\n  }),\n  languageData: {\n    indentOnInput: /^\\s*(\\)|\\}|\\]|then|else|return|satisfies)$/,\n    commentTokens: {\n      line: '//',\n      block: {\n        open: '/*',\n        close: '*/'\n      }\n    }\n  }\n});\n\n/**\n * A language provider for FEEL Unary Tests\n */\nexport const unaryTestsLanguage = feelLanguage.configure({\n  top: 'UnaryTests',\n}, 'FEEL unary tests');\n\n/**\n * Language provider for FEEL Expression\n */\nexport const expressionLanguage = feelLanguage.configure({\n  top: 'Expression'\n}, 'FEEL expression');\n\n\n\n/**\n * Feel language support for CodeMirror.\n *\n * Includes [snippet](#lang-feel.snippets)\n */\nexport function feel(config: {\n  dialect?: 'expression' | 'unaryTests',\n  parserDialect?: string,\n  completions?: CompletionSource[],\n  context?: Record<string, any>\n} = {}) {\n  const language = config.dialect === 'unaryTests' ? unaryTestsLanguage : expressionLanguage;\n\n  const dialect = config.parserDialect;\n  const contextTracker = trackVariables(config.context);\n\n  const contextualLang = language.configure({\n    contextTracker,\n    dialect\n  });\n\n  const completions = config.completions || [\n    snippetCompletion(snippets),\n    keywordCompletions,\n  ].flat();\n\n  return new LanguageSupport(contextualLang, [\n    ...(\n      completions.map(autocomplete => contextualLang.data.of({\n        autocomplete\n      }))\n    )\n  ]);\n\n}"],"names":["snippets","snippetCompletion","label","detail","type","contextualKeyword","options","context","nodes","after","before","keyword","ifInside","completeFromList","boost","keywordCompletions","dontComplete","doComplete","ifExpression","completionSource","allNodes","state","pos","match","matchUp","syntaxTree","resolveInner","_","name","includes","map","s","_extends","matchLeft","node","position","matchChildren","matchRight","direction","child","isError","firstChild","nodeNames","Array","isArray","parent","nodeType","matchedName","find","is","isTop","source","feelLanguage","LRLanguage","define","parser","configure","props","indentNodeProp","add","delimitedIndent","closing","continuedIndent","except","foldNodeProp","Context","foldInside","List","ParenthesizedExpression","FunctionDefinition","last","getChild","from","to","languageData","indentOnInput","commentTokens","line","block","open","close","unaryTestsLanguage","top","expressionLanguage","feel","config","language","dialect","parserDialect","contextTracker","trackVariables","contextualLang","completions","flat","LanguageSupport","autocomplete","data","of"],"mappings":"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"}